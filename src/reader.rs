///! Cache reading API.
///!
///! Provides high-level interface for reading and exploring ld.so.cache files.

use crate::internal::cache_format::{self, CacheInfo as InternalCacheInfo};
use crate::Error;
use std::fs;
use std::io::Write;
use std::path::Path;

/// Information about the cache file
#[derive(Debug, Clone)]
pub struct CacheInfo {
    pub num_entries: usize,
    pub generator: Option<String>,
}

/// A cache entry representing a library
#[derive(Debug, Clone)]
pub struct CacheEntry {
    pub soname: String,
    pub path: String,
    pub arch: String,
    pub hwcap: u64,
    pub flags: u32,
}

/// Reader for ld.so.cache files
pub struct CacheReader {
    data: Vec<u8>,
    info: InternalCacheInfo,
}

impl CacheReader {
    /// Read cache from file path
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        let data = fs::read(path.as_ref())
            .map_err(|e| Error::CacheRead(format!("Failed to read cache: {}", e)))?;

        Self::from_bytes(data)
    }

    /// Parse cache from bytes
    pub fn from_bytes(data: Vec<u8>) -> Result<Self, Error> {
        let info = cache_format::parse_cache(&data)?;

        Ok(Self { data, info })
    }

    /// Get cache metadata
    pub fn info(&self) -> CacheInfo {
        CacheInfo {
            num_entries: self.info.entries.len(),
            generator: self.info.generator.clone(),
        }
    }

    /// Get all entries
    pub fn entries(&self) -> Vec<CacheEntry> {
        self.info
            .entries
            .iter()
            .filter_map(|entry| {
                let soname = self.extract_string(entry.key_offset).ok()?;
                let path = self.extract_string(entry.value_offset).ok()?;
                let arch = decode_arch_flags(entry.flags);

                Some(CacheEntry {
                    soname,
                    path,
                    arch: arch.to_string(),
                    hwcap: entry.hwcap,
                    flags: entry.flags,
                })
            })
            .collect()
    }

    /// Find entries matching a library name
    pub fn find(&self, name: &str) -> Vec<CacheEntry> {
        self.entries()
            .into_iter()
            .filter(|entry| entry.soname.contains(name))
            .collect()
    }

    /// Print cache in ldconfig format
    pub fn print<W: Write>(&self, writer: &mut W) -> Result<(), Error> {
        writeln!(writer, "{} libs found in cache", self.info.entries.len())
            .map_err(|e| Error::CacheWrite(e.to_string()))?;

        for entry in &self.info.entries {
            let libname = self.extract_string(entry.key_offset)?;
            let libpath = self.extract_string(entry.value_offset)?;
            let arch_str = decode_arch_flags(entry.flags);

            write!(writer, "\t{} ({})", libname, arch_str)
                .map_err(|e| Error::CacheWrite(e.to_string()))?;

            if entry.hwcap != 0 {
                write!(writer, ", hwcap: 0x{:016x}", entry.hwcap)
                    .map_err(|e| Error::CacheWrite(e.to_string()))?;
            }

            writeln!(writer, " => {}", libpath).map_err(|e| Error::CacheWrite(e.to_string()))?;
        }

        if let Some(ref generator) = self.info.generator {
            writeln!(writer, "Cache generated by: {}", generator)
                .map_err(|e| Error::CacheWrite(e.to_string()))?;
        }

        Ok(())
    }

    /// Extract null-terminated string from absolute file offset
    fn extract_string(&self, offset: u32) -> Result<String, Error> {
        let start = offset as usize;
        if start >= self.data.len() {
            return Err(Error::CacheRead(format!("Invalid offset: {}", offset)));
        }

        let slice = &self.data[start..];
        let null_pos = slice.iter().position(|&b| b == 0).unwrap_or(slice.len());

        String::from_utf8(slice[..null_pos].to_vec())
            .map_err(|_| Error::CacheRead("Invalid UTF-8 in string".to_string()))
    }
}

/// Decode architecture from flags (matches ldconfig output format)
fn decode_arch_flags(flags: u32) -> &'static str {
    let arch_bits = (flags >> 8) & 0xff;
    match arch_bits {
        0x00 => "libc6",                  // i386/generic ELF
        0x01 => "libc6,SPARC 64-bit",     // SPARC 64-bit
        0x03 => "libc6,x86-64",           // x86_64
        0x04 => "libc6,64bit",            // PowerPC/S390 64-bit
        0x05 => "libc6,64bit",            // PowerPC 64-bit (official)
        0x06 => "libc6,IA-64",            // IA-64
        0x07 => "libc6,MIPS 64-bit",      // MIPS 64-bit
        0x08 => "libc6,x32",              // x32
        0x09 => "libc6,ARM,hard-float",   // ARM hard-float
        0x0a => "libc6,AArch64",          // AArch64
        0x0b => "libc6,ARM,soft-float",   // ARM soft-float
        0x10 => "libc6,RISC-V 64-bit",    // RISC-V lp64d
        _ => "unknown",
    }
}
